    <#
    .SYNOPSIS
        Test SCuBA tool against various outputs for functional testing.

    .DESCRIPTION
        This script executes prexisting provider exports against the Rego code and compares output against saved runs for
        regression testing.

        To run the test on the Rego test results, the user MUST have a folder called GoldenRegressionTests saved somewhere in
        their home directory (e.g., Downloads, Documents, Desktop). The GoldenRegressionTests folder holds sub folders for each
        provider that is being regression tested based on the product name designation used in ScubaGear.  These include aad,
        defender, exo, onedrive, powerplatform, sharepoint, and teams. Each subfolder contains a pair of files: the provider JSON
        and test results JSON. These files MUST be generated using the main branch and are used as master copy references to
        compare against output generated by new runs of ScubaGear by the functional testing tool.  Each file pair must be renamed
        using the following naming convention:
            - SettingsExport.json renamed to ProviderExport-<tennant>.json
            - TestResults.json renamed to TestResults-<tennant>.json

        EXAMPLE
            - ProviderExport-contoso.json
            - TestResults-contoso.json

    .OUTPUTS
        Text output that indicates how many tests were consistent or different from the saved test results.

    .PARAMETER Products
            Takes a comma seperated list of product names to run the script
            against: 'teams', 'exo', 'defender', 'aad', 'powerplatform', 'sharepoint', 'onedrive', '*'. Runs all on default.

    .PARAMETER TestType
            Takes the user's selection of test type: regression, scuba. Runs regression on default.

    .PARAMETER Auto
            Takes the user's selection of automatic test type: Simple, Minimum, Extreme.

    .PARAMETER Out
            Takes the path of the SCuBA's working directory.

    .PARAMETER Save
            Takes the path of where test results from regression test is to be saved.

    .PARAMETER RegressionTests
            Takes the directory path to the 'GoldenRegressionTests' directory.

    .PARAMETER VerboseOutput
            Prints the verbose output for regression tests.

    .PARAMETER Unsuppressed
            Runs SCuBA without report supression so the reports open immediately after generation.

    .EXAMPLE
        .\RunFunctionalTests.ps1
        Running against all Rego regression tests is default, no flags necessary.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -p teams,exo,defender,aad
        Runs all test cases for specified products. Products must be specified with -p parameter.
        Valid product names are: aad, defender, exo, onedrive, powerplatform, sharepoint, teams, and '*'.
        Runs all products on default.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -t Rego -p *
        To run a specific type of test, must indicate test with -t. Possible types are: rego, scuba
        Runs Rego regression test on default.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -a Simple
        To run a predefined set of tests, must indicate type with -a. Possible types are: Simple, Minimum, Extreme
        CAUTION when using Extreme, there are 1957 test cases. Can be used when running against tenant or Rego regression test

    .EXAMPLE
        .\RunFunctionalTests.ps1 -o .\Functional\Reports
        Enter the file path for the SCuBA working directory. This is where the ProviderExport, TestResults, and Report will be generated by the tool.
        The default path is .\Functional\Reports.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -s .\Functional\Archive
        Enter the file path for where the test results from the Rego regression test will be saved. The default path is .\Functional\Archive.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -i .\GoldenRegressionTests
        Enter the directory path where the saved provider exports & test results are for the rego test. The default path is the home directory.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -v
        Outputs the verbose results for the test.

    .EXAMPLE
        .\RunFunctionalTests.ps1 -n
        Choose to not supress the reports from opening immediately after generation.
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('teams', 'exo', 'defender', 'aad', 'powerplatform', 'sharepoint', 'onedrive', '*', IgnoreCase = $false)]
        [Alias('p')]
        [string[]]$ScubaProducts = '*',

        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('regression', 'scuba', IgnoreCase = $false)]
        [Alias('t')]
        [string]$IntegrationTest = '',

        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('Simple', 'Minimum', 'Extreme')]
        [Alias('a')]
        [string]$AutomaticTest = '',

        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [Alias('o')]
        [string]$ScubaOutDirectory = $(Join-Path -Path $(Split-Path -Path $pwd) -ChildPath 'Functional\Reports'),

        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [Alias('s')]
        [string]$RegressionResultDirectory = $(Join-Path -Path $(Split-Path -Path $pwd) -ChildPath 'Functional\Archive'),

        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [Alias('i')]
        [string]$GoldenTestsDirectory = '',

        [Parameter(Mandatory = $false)]
        [Alias('g')]
        [switch]$GenerateGolden,

        [Parameter(Mandatory = $false)]
        [Alias('v')]
        [switch]$VerboseOutput,

        [Parameter(Mandatory = $false)]
        [Alias('r')]
        [switch]$UnsuppressedReport
    )

function Get-GoldenFiles {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('aad', 'defender', 'exo', 'onedrive', 'powerplatform', 'sharepoint', 'teams', '*', IgnoreCase = $false)]
        [string[]]$ScubaProducts,

        [Parameter(Mandatory)]
        [AllowEmptyString()]
        [string]$GoldenTestsDirectory,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ScubaOutDirectory,

        [Parameter(Mandatory)]
        [boolean]$Quiet
    )

    if ($GoldenTestsDirectory -ne '') {
        $GoldenFolderPath = Join-Path -Path $(Get-AbsolutePath $GoldenTestsDirectory) -ChildPath 'GoldenRegressionTests'
    }
    else {
        $GoldenFolderPath = $(Join-Path -Path $(Split-Path -Path $pwd) -ChildPath 'GoldenRegressionTests')
    }
    New-Folders $GoldenFolderPath
    $LogIn = $true

    foreach( $Product in $ScubaProducts) {
        $FolderPath = Join-Path -Path $GoldenFolderPath -ChildPath $Product
        New-Folders $FolderPath

        try {
            Invoke-SCuBA -ProductNames $Product -OutPath $ScubaOutDirectory -LogIn $LogIn -Quiet $Quiet
            $MostRecentFolder = (Get-ChildItem $ScubaOutDirectory -Directory | Sort-Object CreationTime)[-1]
            . .\Redact-SensitiveData.ps1

            try {
                $RedactionParams = @{
                    'InputPath' = $(Join-Path -Path $ScubaOutDirectory -ChildPath $MostRecentFolder);
                    'OutputPath' = $FolderPath;
                    'RedactionDataPath' = $(Join-Path -Path $(Split-Path -Path $pwd) -ChildPath 'Functional');
                }
                Invoke-RedactSensitiveData @RedactionParams
            }
            catch {
                Write-Error "Unknown problem running 'Invoke-RedactSensitiveData', please report."
                Write-Output $_
                exit
            }
            Remove-Item -Recurse $RedactionParams.InputPath
        }
        catch {
            Write-Error "Unknown problem running 'Invoke-SCuBA', please report."
            Write-Output $_
            exit
        }
        $LogIn = $false
    }
    return $GoldenFolderPath
}

function Invoke-SCuBATest {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('aad', 'defender', 'exo', 'onedrive', 'powerplatform', 'sharepoint', 'teams', '*', IgnoreCase = $false)]
        [string[]]$ScubaProducts,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ScubaOutDirectory,

        [Parameter(Mandatory)]
        [boolean]$LogIn,

        [Parameter(Mandatory)]
        [boolean]$Quiet
    )

    try {
        Invoke-SCuBA -ProductNames $ScubaProducts -OutPath $ScubaOutDirectory -LogIn $LogIn -Quiet $Quiet
    }
    catch {
        Write-Output $_
    }

}

function Invoke-RegressionTest {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('aad', 'defender', 'exo', 'onedrive', 'powerplatform', 'sharepoint', 'teams', '*', IgnoreCase = $false)]
        [string[]]$ScubaProducts,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ScubaOutDirectory,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$RegressionResultDirectory,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$GoldenTestsDirectory,

        [Parameter(Mandatory)]
        [boolean]$Quiet
    )

    $ExportFilename = Join-Path -Path $ScubaOutDirectory -ChildPath 'ProviderSettingsExport.json'
    $VerboseString = ' '
    $FailString = ' '
    $TotalCount = 0
    $PassCount = 0

    foreach($Product in $ScubaProducts) {
        $ProviderFilePath = Join-Path -Path $GoldenTestsDirectory -ChildPath $Product
        $ProviderExportFiles = Get-Filenames -FilePath $ProviderFilePath -Key 'ProviderExport'

        if ($ProviderExportFiles[0]) {
            $TotalCount += $ProviderExportFiles[1].Count

            foreach ($ProviderFile in $ProviderExportFiles[1]) {
                Copy-Item -Path $ProviderFile -Destination $ExportFilename

                if (Confirm-FileExists $ExportFilename) {
                    try {
                        $RunCachedParams = @{
                            'ExportProvider' = $false;
                            'Login' = $false;
                            'ProductNames' = $Product;
                            'M365Environment' = 'gcc';
                            'OPAPath' = $(Split-Path -Path $PSScriptRoot | Split-Path);
                            'OutPath' = $ScubaOutDirectory;
                            'Quiet' = $Quiet;
                        }
                        Invoke-RunCached @RunCachedParams
                    }
                    catch {
                        Write-Error "Unknown problem running 'Invoke-RunCached', please report."
                        Write-Output $_
                        Remove-Item $ExportFilename
                        exit
                    }
                    $CompareParams = @{
                        'Product' = $Product;
                        'Filename' = $ProviderFile;
                        'ScubaOutDirectory' = $ScubaOutDirectory;
                        'RegressionResultDirectory' = $RegressionResultDirectory;
                    }
                    $ResultString = Compare-TestResults @CompareParams
                    if ($ResultString.Contains('CONSISTENT')) {
                        $PassCount += 1
                    }
                    else {
                        $FailString += $ResultString
                    }

                    $VerboseString += $ResultString
                    Remove-Item $ExportFilename
                }
            }
        }
        else {
            Write-Warning "$Product is missing, no files for Rego test found`nSkipping......`n" | Out-Host
        }
    }
    return $PassCount, $TotalCount, $VerboseString, $FailString
}

function Invoke-AutomaticTest {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('regression', 'scuba', IgnoreCase = $false)]
        [string]$IntegrationTest,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('Simple', 'Minimum', 'Extreme')]
        [string]$AutomaticTest,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ScubaOutDirectory,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$RegressionResultDirectory,

        [Parameter(Mandatory)]
        [AllowEmptyString()]
        [string]$GoldenTestsDirectory,

        [Parameter(Mandatory)]
        [switch]$VerboseOutput
    )

    $Filename = $(Join-Path -Path $(Split-Path -Path $pwd) -ChildPath "Functional\Auto\$($AutomaticTest)Test.txt")

    if($AutomaticTest -eq 'Extreme') {
        Write-Warning "File has 1957 tests!`n" | Out-Host
        if ((Confirm-UserSelection "Do you wish to continue [y/n]?") -eq $false) {
            Write-Output "Canceling....."
            exit
        }
        Write-Output "Continuing.....`nEnter Ctrl+C to cancel`n"
    }

    if (Confirm-FileExists $Filename) {
        foreach ($Products in Get-Content $Filename) {
            $IntegrationTestParams = @{
                'ScubaProducts' = $Products;
                'IntegrationTest' = $IntegrationTest;
                'ScubaOutDirectory' = $ScubaOutDirectory;
                'RegressionResultDirectory' = $RegressionResultDirectory;
                'VerboseOutput' = $VerboseOutput;
                'UnsuppressedReport' = $false;
            }

            Write-Output "`n`t=== Automatic Testing @($($Products -join ",")) ==="
            if ($GoldenTestsDirectory -ne '') {
                #Invoke-IntegrationTest @IntegrationTestParams -GoldenTestsDirectory $GoldenTestsDirectory
                .\RunFunctionalTests.ps1 @IntegrationTestParams -GoldenTestsDirectory $GoldenTestsDirectory
            }
            else {
                #Invoke-IntegrationTest @IntegrationTestParams
                .\RunFunctionalTests.ps1 @IntegrationTestParams
            }
        }
    }

}

function Compare-TestResults {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Product,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Filename,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ScubaOutDirectory,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$RegressionResultDirectory
    )

    $GoldenRegressionResultFilename = $Filename -replace 'ProviderExport', 'TestResults'
    $GoldenRegressionResultJson = Get-FileContent $GoldenRegressionResultFilename | ConvertFrom-Json
    $TestResultFilename = Get-ChildItem $ScubaOutDirectory -Filter *.json | Where-Object { $_.Name -match 'TestResults' } | Select-Object Fullname
    $SavedFilename = Get-NewFilename -FilePath $GoldenRegressionResultFilename -RegressionResultDirectory $RegressionResultDirectory -Product $Product
    Copy-Item -Path $TestResultFilename.Fullname -Destination $SavedFilename
    $ResultString = ""

    if (Confirm-FileExists $SavedFilename) {
        $TestResultJson = Get-Content $SavedFilename | ConvertFrom-Json

        if (($GoldenRegressionResultJson | ConvertTo-Json -Compress) -ne ($TestResultJson | ConvertTo-Json -Compress)) {
            try {
                code --diff $GoldenRegressionResultFilename $SavedFilename
            }
            catch {
                Compare-Object (($GoldenRegressionResultJson | ConvertTo-Json) -split '\r?\n') (($TestResultJson | ConvertTo-Json) -split '\r?\n')
                Write-Output "`n==== $(Split-Path -Path $GoldenRegressionResultFilename -Leaf -Resolve) vs $(Split-Path -Path $SavedFilename -Leaf -Resolve) ====`n" | Out-Host
            }
            $ResultString = "`n`t$(Split-Path -Path $SavedFilename -Leaf -Resolve) : DIFFERENT"
        }
        else {
            $ResultString = "`n`t$(Split-Path -Path $SavedFilename -Leaf -Resolve) : CONSISTENT"
        }
    }
    return $ResultString
}

function Write-RegoOutput {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('aad', 'defender', 'exo', 'onedrive', 'powerplatform', 'sharepoint', 'teams', '*', IgnoreCase = $false)]
        [string[]]$ScubaProducts,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string[]]$RegoResults,

        [Parameter(Mandatory)]
        [boolean]$VerboseOutput
    )

    if ($VerboseOutput) {
        Write-Output "`n`t=== Testing @($($ScubaProducts -join ",")) ===$($RegoResults[2])"
    }
    elseif ($RegoResults[3] -ne "") {
        Write-Output "`n`t=== Testing @($($ScubaProducts -join ",")) ===$($RegoResults[3])"
    }
    Write-Output "`n`tCONSISTENT $($RegoResults[0])/$($RegoResults[1])`n"
}

function Confirm-FileExists {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Filename
    )

    if (Test-Path -Path $Filename -PathType Leaf) {
        return $true
    }
    else {
        Write-Warning "$Filename not found`nSkipping......`n" | Out-Host
    }
    return $false
}

function Get-NewFilename {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Product,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$RegressionResultDirectory
    )

    $Filename = Split-Path -Path $Filepath -Leaf -Resolve
    $Date = Get-Date -Format 'MMddyyyy'
    $NewFilename = $Filename -replace '[0-9]+\.json', ($Date + '.json')

    return Join-Path -Path (Get-Item $RegressionResultDirectory) -ChildPath $($Product+$NewFilename)
}

function Get-FileContent {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$File
    )

    if (Confirm-FileExists $File) {
        return Get-Content $File
    }
    return $null

}

function Get-Filenames {
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', 'Key',
    Justification = 'variable is used in another scope')]
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$Key
    )

    try {
        $Files = (Get-ChildItem  $FilePath -ErrorAction Stop | Where-Object { $_.Name -match $Key } | Select-Object FullName).FullName
        return $true, $Files
    }
    catch {
        return $false
    }
}

function Get-AbsolutePath {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$FilePath
    )

    $NewFilePath = Get-ChildItem -Recurse -Filter $(Split-Path -Path $FilePath -Leaf) -Directory -ErrorAction SilentlyContinue -Path $(Split-Path -Path $FilePath) | Select-Object FullName

    if ($null -eq $NewFilePath) {
        Write-Error "$FilePath NOT FOUND" | Out-Host
        exit
    }

    if($NewFilePath.Count -gt 1) {
        Write-Warning "Multiple Directories found for $(Split-Path -Path $FilePath -Leaf), using: $($NewFilePath[-1].fullname)" | Out-Host
        $NewFilePath = $NewFilePath[-1]
    }
    return $NewFilePath.FullName

}

function New-Folders {
    param (
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [String[]]$Folders
    )

    foreach ($Folder in $Folders) {
        if ((Test-Path $Folder) -eq $false) {
            New-Item $Folder -ItemType Directory | Out-Null
        }
    }
}

Set-Location $(Split-Path -Path $PSScriptRoot | Split-Path)
    $ManifestPath = Join-Path -Path "./PowerShell" -ChildPath "ScubaGear"
    Remove-Module "ScubaGear" -ErrorAction "SilentlyContinue"
    Import-Module $ManifestPath -ErrorAction Stop
    Set-Location $PSScriptRoot

    New-Folders $ScubaOutDirectory
    $ScubaOutDirectory = Get-AbsolutePath $ScubaOutDirectory
    $UnsuppressedReport = -not $UnsuppressedReport

    if ($AutomaticTest -ne '') {
        $IntegrationTestParams = @{
            'IntegrationTest' = $IntegrationTest;
            'AutomaticTest' = $AutomaticTest;
            'ScubaOutDirectory' = $ScubaOutDirectory;
            'RegressionResultDirectory' = $RegressionResultDirectory;
            'GoldenTestsDirectory' = $GoldenTestsDirectory;
            'VerboseOutput' = $VerboseOutput;
        }

        Invoke-AutomaticTest @IntegrationTestParams
        exit
    }

    if ($ScubaProducts[0] -eq '*') {
        $UnitTestPath = $(Join-Path -Path $(Split-Path -Path $pwd) -ChildPath 'Unit\Rego')
        $ScubaProducts = $((Get-ChildItem -Path $UnitTestPath -Recurse -Directory -Force -ErrorAction SilentlyContinue |
        Select-Object Name).Name).toLower()
    }

    if ($GenerateGolden) {
        $GoldenFileParams = @{
            'ScubaProducts' = $ScubaProducts;
            'ScubaOutDirectory' = $ScubaOutDirectory;
            'GoldenTestsDirectory' = $GoldenTestsDirectory;
            'Quiet' = $UnsuppressedReport;
        }
        $GoldenTestsDirectory = Get-GoldenFiles @GoldenFileParams
    }

    switch ($IntegrationTest) {
        'regression' {
            $ScubaOutDirectory = Join-Path -Path $ScubaOutDirectory -ChildPath "Regression"
            New-Folders $ScubaOutDirectory,$RegressionResultDirectory

            if ($GoldenTestsDirectory -eq '') {
                $GoldenTestsDirectory = Get-AbsolutePath $(Join-Path -Path $Home -ChildPath 'GoldenRegressionTests')
            }

            $RegressionResultDirectory = Get-AbsolutePath $RegressionResultDirectory
            $RegressionTestParams = @{
                'ScubaProducts' = $ScubaProducts;
                'ScubaOutDirectory' = $ScubaOutDirectory;
                'RegressionResultDirectory' = $RegressionResultDirectory;
                'GoldenTestsDirectory' = $GoldenTestsDirectory;
                'Quiet' = $UnsuppressedReport;
            }

            $OutputParams = @{
                'ScubaProducts' = $ScubaProducts;
                'RegoResults' = $(Invoke-RegressionTest @RegressionTestParams);
                'VerboseOutput' = $VerboseOutput;
            }
            Write-RegoOutput  @OutputParams
        }
        'scuba' {
            $SCuBATestParams = @{
                'ScubaProducts' = $ScubaProducts;
                'ScubaOutDirectory' = $ScubaOutDirectory;
                'LogIn' = $true;
                'Quiet' = $UnsuppressedReport;
            }
            Invoke-SCuBATest @SCuBATestParams
        }
        Default {
            exit
        }
    }